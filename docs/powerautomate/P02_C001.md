---
layout: default
title: 高速で配列から値を探すフロー
parent: PowerAutomate
nav_order: 1
nav_exclude: false
---

# **高速で配列から値を探すフロー**

> 指定された範囲内で特定の値を検索し、その値に対応する別の値を返すフローを２つ紹介します。<br>
> これはエクセルのLookUp関数に相当する処理です。<br>
> 
> 高速に検索できるのは[「2．文字列操作による検索フロー」](#2文字列操作による検索フロー)です。<br>

## 検索対象の配列
この配列から"メロン"の価格を取得するフローを比較します。<br>
メロンが複数ある場合は最初に見つかった価格を取得します。<br>
ちなみに、配列番号は[0]始まりのため、メロンが含まれている配列番号は[2]です。<br>

```json
[
  { "商品名": "りんご", "価格": 1000 },
  { "商品名": "ぶどう", "価格": 2000 },
  { "商品名": "メロン", "価格": 3000 },
  { "商品名": "いちご", "価格": 4000 }
]
```

# 1．順次検索フロー（LookUp関数）

## 検索方法
範囲の最初から順番に検索値を探していく方法。<br>
商品名列をりんご→ぶどう→…と順に検索し、メロンが見つかった時の価格列を取得します。<br>
> シンプルで理解しやすい方法ですが、配列サイズに比例して時間がかかります。<br>
> 仮に1回の判定に0.1秒かかる場合、配列サイズが6000なら最大10分、60000なら最大100分かかります。<br>

## Power Automateでの具体的なアクション
1. **Initialize Variable アクションを使用して、配列を初期化します。**
   - 名前: Products
   - 種類: Array
   - 値:
     ```json
     [
       { "商品名": "りんご", "価格": 1000 },
       { "商品名": "ぶどう", "価格": 2000 },
       { "商品名": "メロン", "価格": 3000 },
       { "商品名": "いちご", "価格": 4000 }
     ]
     ```
2. **Initialize Variable アクションを使用して、検索値を初期化します。**
   - 名前: SearchValue
   - 種類: String
   - 値: メロン

3. **Apply to each アクションを使用して、配列内の各アイテムをループします。**
   - 配列: Products

4. **Condition アクションを使用して、現在のアイテムの商品名が検索値と一致するかを確認します。**
   - 条件: `@equals(items('Apply_to_each')?['商品名'], variables('SearchValue'))`

5. **条件が一致する場合、Set Variable アクションを使用して、価格を取得します。**
   - 名前: Price
   - 値: `@items('Apply_to_each')?['価格']`

# 2．文字列操作による検索フロー

## 検索方法
文字列操作により、検索値の配列番号を特定し目的の値を取得する方法。<br>
配列を1つの文字列に結合し、検索ワードで分解します。<br>
最初の文字列を配列に戻し、そのサイズから配列番号を求めて価格を取得します。<br>
 > 配列サイズに関係なく高速で検索が可能で、フローの圧縮が可能です。<br>
 > 文字列操作の理解が必要で、エラー箇所の特定が難しい場合があります。<br>

## Power Automateでの具体的なアクション
1. **Initialize Variable アクションを使用して、配列を初期化します。**
   - 名前: Products
   - 種類: Array
   - 値:
     ```json
     [
       { "商品名": "りんご", "価格": 1000 },
       { "商品名": "ぶどう", "価格": 2000 },
       { "商品名": "メロン", "価格": 3000 },
       { "商品名": "いちご", "価格": 4000 }
     ]
     ```
2. **Initialize Variable アクションを使用して、検索値を初期化します。**
   - 名前: SearchValue
   - 種類: String
   - 値: メロン
   
3. **Select アクションを使用して、商品名の配列を作成します。**
   - 名前: ProductNames
   - 配列: Products
   - マッピング: 商品名

   - 例）ProductNames = `[“りんご”, “ぶどう”, “メロン”, “いちご”]`
4. **Compose アクションを使用して、配列番号を使用して価格を取得します。**
   - 名前: Price
   - 式: `@outputs('Products')[sub(length(split(first(split(join(@outputs('ProductNames'), ‘||’), @{variables('SearchValue')})), ‘||’)), 1)]['価格']`

   - 例）Price = 3000

  > ここでは[4.1~4.7のアクション](#4147のアクション)を圧縮して1つの式にしています。<br>
  > アクション数が減るので、フローをシンプルにすることができます。<br>
###  ＜うまくいかない場合＞
  > 4のアクションを[4.1~4.7のアクション](#4147のアクション)に置き換えて、フローをテストしましょう。<br>
  > フローは長くなりますが、処理速度はほとんど変わらないため、これでうまく動く場合はそのままでも問題ありません。<br>
  > アクションを圧縮したい場合は、1つずつ式を統合してアクションを圧縮していくとうまくいきます。<br>

###  ＜「式が無効です」がでる場合＞
  > 式自体に誤りがないか確認してください。<br>
  > 解決できない場合は、[4.1~4.7のアクション](#4147のアクション)でフローを作成し、テスト後に1つずつ圧縮しましょう。<br>
  > - [ ] ( )の数に過不足がないか<br>
  > - [ ] 「'」（アポストロフィー）、「`」（バッククオート）、「"」（ダブルクォーテーション）の誤りはないか<br>
  > - [ ] 全角半角の間違いはないか<br>
  > - [ ] 関数の引数の過不足はないか<br>
  > - [ ] 綴り間違いはないか<br>

###  ＜フローを実行するとエラーがでる場合＞
  > 1つのアクションで複数の処理を行っているため、エラーが出た時に原因がわかりにくくなります。<br>
  > この場合も、[4.1~4.7のアクション](#4147のアクション)で作成し、どこでエラーが起きているかを確認してください。<br>
  

* * *
###  4.1~4.7のアクション

4-1. **Join アクションを使用して、商品名の配列を’||'で結合し文字列に変換します。**
   - 名前: JoinedProductNames
   - 配列: `@outputs('Select')`
   - 区切り記号: `||`

   - 例）JoinedProductNames = `“りんご||ぶどう||メロン||いちご”`

4-2. **Split アクションを使用して、検索値で文字列を分割します。**
   - 名前: SplitBySearchValue
   - 文字列: `@outputs('Join')`
   - 区切り記号: `@{variables('SearchValue')}`

   - 例）SplitBySearchValue = `[“りんご||ぶどう||","||いちご”]`

4-3. **First アクションを使用して、分割された配列の最初の値を取得します。**
   - 名前: FirstSplit
   - 配列: `@outputs('Split')`

   - 例）FirstSplit = `“りんご||ぶどう||"`

4-4. **Split アクションを使用して、`'||'`で文字列を分割します。**
   - 名前: SplitByPipe
   - 文字列: `@outputs('First')`
   - 区切り記号: `||`

   - 例）SplitByPipe = `[“りんご","ぶどう",""]`

4-5. **Length アクションを使用して、配列の長さを取得します。**
   - 名前: ArrayLength
   - 配列: `@outputs('Split_2')`

   - 例）ArrayLength = 3

4-6. **Subtract アクションを使用して、配列の長さから1を引いて配列番号を取得します。**
   - 名前: ArrayIndex
   - 数値1: `@outputs('Length')`
   - 数値2: 1

   - 例）ArrayIndex = 2

4-7. **Compose アクションを使用して、配列番号を使用して価格を取得します。**
   - 名前: Price
   - 式: `@outputs('Products')[outputs('Subtract')]['価格']`

   - 例）Price = 3000